<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>JSP简表</title>
</head>
<body>
<div id="f_title">JSP语法简表</div>
<div id="f_ads" style="margin-left:50px;height:20px;">
<script type="text/javascript"><!--
google_ad_client = "pub-0460916971781510";
/* 468x15 链接单元 */
google_ad_slot = "0725580076";
google_ad_width = 468;
google_ad_height = 15;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div id="f_content">
<div id="f_cot_main">
	HTML 注释 <BR>在客户端显示一个注释. <BR><BR>JSP 语法 <BR>&lt;!-- comment [ &lt;%= expression %&gt; ] --&gt; <BR>例子 1 <BR>&lt;!-- This file displays the user login screen --&gt; <BR>在客户端的HTML源代码中产生和上面一样的数据： <BR><BR>&lt;!-- This file displays the user login screen --&gt; <BR>例子 2 <BR>&lt;!-- This page was loaded on &lt;%= (new java.util.Date()).toLocaleString() %&gt; --&gt; <BR>在客户端的HTML源代码中显示为: <BR><BR>&lt;!-- This page was loaded on January 1, 2000 --&gt; <BR>描述 <BR>这种注释和HTML中很像，也就是它可以在"查看源代码"中看到. <BR><BR>唯一有些不同的就是，你可以在这个注释中用表达式（例子2所示).这个表达示是不定的，由页面不同而不同，你能够使用各种表达式，只要是合法的就行。更多的请看表达式 <BR><BR>========================================================= <BR>隐藏注释 <BR>写在JSP程序中，但不是发给客户。 <BR><BR>JSP 语法 <BR>&lt;%-- comment --%&gt; <BR>例子： <BR>&lt;%@ page language="java" %&gt; <BR>&lt;html&gt; <BR>&lt;head&gt;&lt;title&gt;A Comment Test&lt;/title&gt;&lt;/head&gt; <BR>&lt;body&gt; <BR>&lt;h2&gt;A Test of Comments&lt;/h2&gt; <BR>&lt;%-- This comment will not be visible in the page source --%&gt; <BR>&lt;/body&gt; <BR>&lt;/html&gt; <BR>描述 <BR>用隐藏注释标记的字符会在JSP编译时被忽略掉。这个注释在你希望隐藏或注释你的JSP程序时是很有用的。JSP编译器不是会对&lt;%--and--%&gt;之间的语句进行编译的，它不会显示在客户的浏览器中，也不会在源代码中看到 <BR><BR>在&lt;%-- --%&gt;之间，你可以任意写注释语句，但是不能使用 "--%&gt;",如果你非要使用请用"--%&gt;". <BR><BR><BR><BR>================================================================ <BR>声明 <BR>在JSP程序中声明合法的变量和方法 <BR><BR>JSP 语法 <BR>&lt;%! declaration; [ declaration; ]+ ... %&gt; <BR>例子 <BR>&lt;%! int i = 0; %&gt; <BR>&lt;%! int a, b, c; %&gt; <BR>&lt;%! Circle a = new Circle(2.0); %&gt; <BR>描述 <BR>声明你将要在JSP程序中用到的变量和方法。你也必须这样做，不然会出错. <BR><BR>你可以一次性声明多个变量和方法，只要以";"结尾就行，当然这些声明在Java中要是合法的。 <BR><BR>当你声明方法或变量时，请注意以下的一些规则: <BR><BR>声明必须以";"结尾(Scriptlet有同样的规则，但是 表达式就不同了). <BR>你可以直接使用在&lt;% @ page %&gt;中被包含进来的已经声明的变量和方法，不需要对它们重新进行声明. <BR>一个声明仅在一个页面中有效。如果你想每个页面都用到一些声明，最好把它们写成一个单独的文件，然后用&lt;%@ include %&gt;或&lt;jsp:include &gt;元素包含进来。 <BR><BR>================================================================== <BR>表达式 <BR>包含一个符合JSP语法的表达式 <BR><BR>JSP 语法 <BR>&lt;%= expression %&gt; <BR>例子 <BR>&lt;font color="blue"&gt;&lt;%= map.size() %&gt;&lt;/font&gt; <BR>&lt;b&gt;&lt;%= numguess.getHint() %&gt;&lt;/b&gt;. <BR>描述 <BR>表达式元素表示的是一个在脚本语言中被定义的表达式，在运行后被自动转化为字符串，然后插入到这个表达示在JSP文件的位置显示。因为这个表达式的值已经被转化为字符串，所以你能在一行文本中插入这个表达式（形式和ASP完全一样). <BR><BR>当你在JSP中使用表达式时请记住以下几点： <BR><BR>你不能用一个分号（"；"）来作为表达式的结束符.但是同样的表达式用在scriptlet中就需要以分号来结尾了！查看Scriptlet <BR>这个表达式元素能够包括任何在Java Language Specification中有效的表达式. <BR>有时候表达式也能做为其它JSP元素的属性值.一个表达式能够变得很复杂，它可能由一个或多个表达式组成，这些表达式的顺序是从左到右。 <BR><BR>================================================================== <BR>Scriptlet <BR>包含一个有效的程序段. <BR><BR>JSP 语法 <BR>&lt;% code fragment %&gt; <BR>例子 <BR>&lt;% <BR>String name = null; <BR>if (request.getParameter("name") == null) { <BR>%&gt; <BR>&lt;%@ include file="error.html" %&gt; <BR>&lt;% <BR>} else { <BR>foo.setName(request.getParameter("name")); <BR>if (foo.getName().equalsIgnoreCase("integra")) <BR>name = "acura"; <BR>if (name.equalsIgnoreCase( "acura" )) { <BR>%&gt; <BR>描述 <BR>一个scriptlet能够包含多个jsp语句，方法，变量，表达式 <BR><BR>因为scriptlet,我们便能做以下的事: <BR><BR>声明将要用到的变量或方法（参考 声明). <BR>编写JSP表达式（参考 表达式). <BR>使用任何隐含的对象和任何用&lt;jsp:useBean&gt;声明过的对象 <BR>编写JSP语句 (如果你在使用Java语言，这些语句必须遵从Java Language Specification,). <BR>任何文本，HTML标记，JSP元素必须在scriptlet之外 <BR>当JSP收到客户的请求时，scriptlet就会被执行，如果scriptlet有显示的内容，这些显示的内容就被存在out对象中。 <BR><BR>======================================================================= <BR>Include 指命 <BR>在JSP中包含一个静态的文件，同时解析这个文件中的JSP语句. <BR><BR>JSP 语法 <BR>&lt;%@ include file="relativeURL" %&gt; <BR>例子 <BR>include.jsp: <BR>&lt;html&gt; <BR>&lt;head&gt;&lt;title&gt;An Include Test&lt;/title&gt;&lt;/head&gt; <BR>&lt;body bgcolor="white"&gt; <BR>&lt;font color="blue"&gt; <BR>The current date and time are <BR>&lt;%@ include file="date.jsp" %&gt; <BR>&lt;/font&gt; <BR>&lt;/body&gt; <BR>&lt;/html&gt; <BR>date.jsp: <BR>&lt;%@ page import="java.util.*" %&gt; <BR>&lt;%= (new java.util.Date() ).toLocaleString() %&gt; <BR>Displays in the page: <BR>The current date and time are <BR>Aug 30, 1999 2:38:40 <BR><BR>描述 <BR>&lt;%@include %&gt;指命将会在JSP编译时插入一个包含文本或代码的文件，当你使用&lt;%@ include %&gt;指命时，这个包含的过程就当是静态的。静态的包含就是指这个被包含的文件将会被插入到JSP文件中去，这个包含的文件可以是JSP文件，HTML文件，文本文件。如果包含的是JSP文件，这个包含的JSP的文件中代码将会被执行。 <BR><BR>如果你仅仅只是用include 来包含一个静态文件。那么这个包含的文件所执行的结果将会插入到JSP文件中放&lt;% @ include %&gt;的地方。一旦包含文件被执行，那么主JSP文件的过程将会被恢复，继续执行下一行. <BR><BR>这个被包含文件可以是html文件，jsp文件，文本文件，或者只是一段Java代码，但是你得注意在这个包含文件中不能使用&lt;html&gt;,&lt;/html&gt;,&lt;body&gt;,&lt;/body&gt;标记，因为这将会影响在原JSP文件中同样的标记 ，这样做有时会导致错误. <BR><BR>有一些&lt;%@ include %&gt;指命的行为是以特殊的JSP编译条件为基础，比如： <BR><BR>这个被包含的文件必须对所有客户都有开放且必须f有效，或者它有安全限制 <BR>如果这个包含文件被改变，包含此文件的JSP文件将被重新编译 <BR>属性: <BR>file="relativeURL" <BR>这个包含文件的路径名一般来说是指相对路径，不需要什么端口，协议，和域名，如下: <BR><BR>"error.jsp""/templates/onlinestore.html""/beans/calendar.jsp" <BR><BR>如果这个路径以"/"开头，那么这个路径主要是参照JSP应用的上下关系路径，如果路径是以文件名或目录名开头，那么这个路径就是正在使用的JSP文件的当前路径. <BR><BR>================================================================== <BR>Page 指令 <BR>定义JSP文件中的全局属性. <BR><BR>JSP 语法 <BR>&lt;%@ page <BR>[ language="java" ] <BR>[ extends="package.class" ] <BR>[ import="{package.class / package.*}, ..." ] <BR>[ session="true / false" ] <BR>[ buffer="none / 8kb / sizekb" ] <BR>[ autoFlush="true / false" ] <BR>[ isThreadSafe="true / false" ] <BR>[ info="text" ] <BR>[ errorPage="relativeURL" ] <BR>[ contentType="mimeType [ ;charset=characterSet ]" / "text/html ; charset=ISO-8859-1" ] <BR>[ isErrorPage="true / false" ] <BR>%&gt; <BR>例子 <BR>&lt;%@ page import="java.util.*, java.lang.*" %&gt; <BR>&lt;%@ page buffer="5kb" autoFlush="false" %&gt; <BR>&lt;%@ page errorPage="error.jsp" %&gt; <BR>描述 <BR>&lt;%@ page %&gt;指令作用于整个JSP页面，同样包括静态的包含文件。但是&lt;% @ page %&gt;指令不能作用于动态的包含文件，比如 &lt;jsp:include&gt; <BR><BR>你可以在一个页面中用上多个&lt;% @ page %&gt;指令，但是其中的属性只能用一次，不过也有个例外，那就是import属性。因为import属性和Java中的import语句差不多(参照Java Language)，所以你就能多用此属性几次了. <BR><BR>无论你把&lt;% @ page %&gt;指令放在JSP的文件的哪个地方，它的作用范围都是整个JSP页面。不过，为了JSP程序的可读性，以及好的编程习惯，最好还是把它放在JSP文件的顶部. <BR><BR>属性 <BR>language="java" <BR>声明脚本语言的种类，暂时只能用"java" <BR><BR>extends="package.class" <BR>标明JSP编译时需要加入的Java Class的全名，但是得慎重的使用它，它会限制JSP的编译能力. <BR><BR>import="{package.class / package.* }, ..." <BR>需要导入的Java包的列表，这些包就作用于程序段，表达式，以及声明。 <BR><BR>下面的包在JSP编译时已经导入了，所以你就不需要再指明了: <BR><BR>java.lang.* <BR>javax.servlet.* <BR>javax.servlet.jsp.* <BR>javax.servlet.http.* <BR><BR>session="true / false" <BR>设定客户是否需要HTTP Session.（学过ASP的人，应该对它不陌生)如果它为true,那么Session是有用的。 <BR><BR>如果它有false,那么你就不能使用session对象，以及定义了scope=session的&lt;jsp:useBean&gt;元素。这样的使用会导致错误. <BR><BR>缺省值是true. <BR><BR>buffer="none / 8kb / sizekb" <BR>buffer的大小被out对象用于处理执行后的JSP对客户浏览器的输出。缺省值是8kb <BR><BR>autoFlush="true / false" <BR>设置如果buffer溢出，是否需要强制输出，如果其值被定义为true(缺省值)，输出正常，如果它被设置为false,如果这个buffer溢出，就会导致一个意外错误的发生.如果你把buffer设置为none,那么你就不能把autoFlush设置为false. <BR><BR>isThreadSafe="true / false" <BR>设置Jsp文件是否能多线程使用。缺省值是true,也就是说，JSP能够同时处理多个用户的请求，如果设置为false，一个jsp只能一次处理一个请求 <BR><BR>info="text" <BR>一个文本在执行JSP将会被逐字加入JSP中，你能够使用Servlet.getServletInfo方法取回。 <BR><BR>errorPage="relativeURL" <BR>设置处理异常事件的JSP文件。 <BR><BR>isErrorPage="true / false" <BR>设置此页是否为出错页，如果被设置为true,你就能使用exception对象. <BR><BR>contentType="mimeType [ ;charset=characterSet ]" / "text/html;charset=ISO-8859-1" <BR>设置MIME类型 。缺省MIME 类型是: text/html, 缺省字符集为 ISO-8859-1. <BR><BR>================================================================= <BR>Taglib 指令 <BR>定义一个标签库以及其自定义标签的前缀. <BR><BR>JSP 语法 <BR>&lt;%@ taglib uri="URIToTagLibrary" prefix="tagPrefix" %&gt; <BR>例子 <BR>&lt;%@ taglib uri="http://www.jspcentral.com/tags" prefix="public" %&gt; <BR>&lt;public:loop&gt; <BR>. <BR>. <BR>&lt;/public:loop&gt; <BR>描述 <BR>&lt;% @ taglib %&gt;指令声明此JSP文件使用了自定义的标签，同时引用标签库，也指定了他们的标签的前缀。 <BR><BR>这里自定义的标签含有标签和元素之分。因为JSP文件能够转化为XML,所以了解标签和元素之间的联系很重要。标签只不过是一个在意义上被抬高了点的标记，是JSP元素的一部分。JSP元素是JSP语法的一部分，和XML一样有开始标记和结束标记。元素也可以包含其它的文本，标记，元素。比如，一个jsp:plugin元素有&lt;jsp:plugin&gt;开始标记和&lt;/jsp:plugin&gt;结束标记，同样也可以有&lt;jsp:params&gt;和&lt;jsp:fallback&gt;元素. <BR><BR>你必须在使用自定义标签之前使用&lt;% @ taglib %&gt;指令，而且你可以在一个页面中多次使用，但是前缀只能使用一次 <BR><BR>属性 <BR>uri="URIToTagLibrary" <BR>Uniform Resource Identifier (URI)根据标签的前缀对自定义的标签进行唯一的命名，URI可以是以下的内容: <BR><BR>　 <BR><BR>Uniform Resource Locator (URL), 由 RFC 2396 定义, 查看<A href="http://www.hut.fi/u/jkorpela/rfc/2396/full.html" target=_blank><FONT color=#002c99><U> http://www.hut.fi/u/jkorpela/rfc/2396/full.html</U></FONT></A> <BR>　 <BR><BR>Uniform Resource Name (URN), 由 RFC 2396定义 <BR>　 <BR><BR>一个相对或绝对的路径 <BR>prefix="tagPrefix" <BR>在自定义标签之前的前缀，比如，在&lt;public:loop&gt;中的public，如果这里不写public，那么这就是不合法的。请不要用jsp, jspx, java, javax, servlet, sun, 和sunw做为你的前缀 <BR><BR>===================================================================== <BR>&lt;jsp:forward&gt; <BR>重定向一个HTML文件，JSP文件，或者是一个程序段. <BR><BR>JSP 语法 <BR>&lt;jsp:forward page={"relativeURL" / "&lt;%= expression %&gt;"} /&gt; <BR>or <BR>&lt;jsp:forward page={"relativeURL" / "&lt;%= expression %&gt;"} &gt; <BR>&lt;jsp:param name="parameterName" <BR>value="{parameterValue / &lt;%= expression %&gt;}" /&gt;+ <BR>&lt;/jsp:forward&gt; <BR>例子 <BR>&lt;jsp:forward page="/servlet/login" /&gt; <BR>&lt;jsp:forward page="/servlet/login"&gt; <BR>&lt;jsp:param name="username" value="jsmith" /&gt; <BR>&lt;/jsp:forward&gt; <BR>描述 <BR>&lt;jsp:forward&gt;标签从一个JSP文件向另一个文件传递一个包含用户请求的request对象.&lt;jsp:forward&gt;标签以下的代码，将不能执行. <BR><BR>你能够向目标文件传送参数和值，在这个例子中我们传递的参数名为username,值为scott,如果你使用了&lt;jsp:param&gt;标签的话，目标文件必须是一个动态的文件，能够处理参数. <BR><BR>如果你使用了非缓冲输出的话，那么使用&lt;jsp:forward&gt;时就要小心。如果在你使用&lt;jsp:forward&gt;之前，jsp文件已经有了数据，那么文件执行就会出错. <BR><BR>属性 <BR>page="{relativeURL / &lt;%= expression %&gt;}" <BR>这里是一个表达式或是一个字符串用于说明你将要定向的文件或URL.这个文件可以是JSP,程序段，或者其它能够处理request对象的文件(如asp,cgi,php). <BR><BR>&lt;jsp:param name="parameterName" value="{parameterValue / &lt;%= expression %&gt;}" /&gt;+ <BR>向一个动态文件发送一个或多个参数，这个文件一定是动态文件. <BR><BR>如果你想传递多个参数，你可以在一个JSP文件中使用多个&lt;jsp:param&gt;。name指定参数名，value指定参数值. <BR><BR>====================================================================== <BR>&lt;jsp:getProperty&gt; <BR>获取Bean的属性值，用于显示在页面中 <BR><BR>JSP 语法 <BR>&lt;jsp:getProperty name="beanInstanceName" property="propertyName" /&gt; <BR>例子 <BR>&lt;jsp:useBean id="calendar" scope="page" class="employee.Calendar" /&gt; <BR>&lt;h2&gt; <BR>Calendar of &lt;jsp:getProperty name="calendar" property="username" /&gt; <BR>&lt;/h2&gt; <BR>描述 <BR>这个&lt;jsp:getProperty&gt;元素将获得Bean的属性值，并可以将其使用或显示在JSP页面中.在你使用&lt;jsp:getProperty&gt;之前，你必须用&lt;jsp:useBean&gt;创建它. <BR><BR>&lt;jsp:getProperty&gt;元素有一些限制: <BR><BR>你不能使用&lt;jsp:getProperty&gt;来检索一个已经被索引了的属性 <BR>你能够和JavaBeans组件一起使用&lt;jsp:getProperty&gt;,但是不能与Enterprise Bean一起使用。 <BR>属性 <BR>name="beanInstanceName" <BR>bean的名字,由&lt;jsp:useBean&gt;指定 <BR><BR>property="propertyName" <BR>所指定的Bean的属性名。 <BR><BR>技巧: <BR>在sun的JSP参考中提到，如果你使用&lt;jsp:getProperty&gt;来检索的值是空值，那么NullPointerException将会出现，同时如果使用程序段或表达式来检索其值，那么在浏览器上出现的是null（空). <BR><BR>====================================================================== <BR>&lt;jsp:include&gt; <BR>包含一个静态或动态文件. <BR><BR>JSP 语法 <BR>&lt;jsp:include page="{relativeURL / &lt;%= expression%&gt;}" flush="true" /&gt; <BR>or <BR>&lt;jsp:include page="{relativeURL / &lt;%= expression %&gt;}" flush="true" &gt; <BR>&lt;jsp:param name="parameterName" value="{parameterValue / &lt;%= expression %&gt;}" /&gt;+ <BR>&lt;/jsp:include&gt; <BR>Examples <BR>&lt;jsp:include page="scripts/login.jsp" /&gt; <BR>&lt;jsp:include page="copyright.html" /&gt; <BR>&lt;jsp:include page="/index.html" /&gt; <BR>&lt;jsp:include page="scripts/login.jsp"&gt; <BR>&lt;jsp:param name="username" value="jsmith" /&gt; <BR>&lt;/jsp:include&gt; <BR><BR>描述 <BR>&lt;jsp:include&gt;元素允许你包含动态文件和静态，这两种包含文件的结果是不同的。如果文件仅是静态文件，那么这种包含仅仅是把包含文件的内容加到jsp文件中去，而如果这个文件动态的，那么这个被包含文件也会被Jsp编译器执行(这一切与asp相似) <BR><BR>你不能从文件名上判断一个文件是动态的还是静态的，比如aspcn.asp 就有可能只是包含一些信息而已，而不需要执行。&lt;jsp:include&gt;能够同时处理这两种文件，因此你就不需要包含时还要判断此文件是动态的还是静态的. <BR><BR>如果这个包含文件是动态的，那么你还可以用&lt;jsp:param&gt;还传递参数名和参数值。 <BR><BR>属性 <BR>page="{relativeURL / &lt;%= expression %&gt;}" <BR>参数为一相对路径，或者是代表相对路径的表达式. <BR><BR>flush="true" <BR>这里你必须使用flush="true",你不能使用false值.缺省值为false <BR><BR>&lt;jsp:param name="parameterName" value="{parameterValue / &lt;%= expression %&gt; }" /&gt;+ <BR>&lt;jsp:param&gt;子句能让你传递一个或多个参数给动态文件 <BR><BR>你能在一个页面中使用多个&lt;jsp:param&gt;来传递多个参数. <BR><BR>================================================================== <BR>&lt;jsp:plugin&gt; <BR>执行一个applet或Bean,有可能的话还要下载一个Java插件用于执行它. <BR><BR>JSP 语法 <BR>&lt;jsp:plugin <BR>type="bean / applet" <BR>code="classFileName" <BR>codebase="classFileDirectoryName" <BR>[ name="instanceName" ] <BR>[ archive="URIToArchive, ..." ] <BR>[ align="bottom / top / middle / left / right" ] <BR>[ height="displayPixels" ] <BR>[ width="displayPixels" ] <BR>[ hspace="leftRightPixels" ] <BR>[ vspace="topBottomPixels" ] <BR>[ jreversion="JREVersionNumber / 1.1" ] <BR>[ nspluginurl="URLToPlugin" ] <BR>[ iepluginurl="URLToPlugin" ] &gt; <BR>[ &lt;jsp:params&gt; <BR>[ &lt;jsp:param name="parameterName" value="{parameterValue / &lt;%= expression %&gt;}" /&gt; ]+ <BR>&lt;/jsp:params&gt; ] <BR><BR>[ &lt;jsp:fallback&gt; text message for user &lt;/jsp:fallback&gt; ] <BR><BR>&lt;/jsp:plugin&gt; <BR><BR>例子 <BR>&lt;jsp:plugin type=applet code="Molecule.class" codebase="/html"&gt; <BR>&lt;jsp:params&gt; <BR>&lt;jsp:param name="molecule" value="molecules/benzene.mol" /&gt; <BR>&lt;/jsp:params&gt; <BR>&lt;jsp:fallback&gt; <BR>&lt;p&gt;Unable to load applet&lt;/p&gt; <BR>&lt;/jsp:fallback&gt; <BR>&lt;/jsp:plugin&gt; <BR>描述 <BR>&lt;jsp:plugin&gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。 <BR><BR>当Jsp文件被编译，送往浏览器时，&lt;jsp:plugin&gt;元素将会根据浏览器的版本替换成&lt;object&gt;或者&lt;embed&gt;元素。注意，&lt;object&gt;用于HTML 4.0 ，&lt;embed&gt;用于HTML 3.2. <BR><BR>一般来说，&lt;jsp:plugin&gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。具体如下: <BR><BR>属性 <BR>type="bean / applet" <BR>.将被执行的插件对象的类型，你必须得指定这个是Bean还是applet,因为这个属性没有缺省值. <BR><BR>code="classFileName" <BR>将会被Java插件执行的Java Class的名字，必须以.class结尾。这个文件必须存在于codebase属性指定的目录中. <BR><BR>codebase="classFileDirectoryName" <BR>将会被执行的Java Class文件的目录（或者是路径)，如果你没有提供此属性，那么使用&lt;jsp:plugin&gt;的jsp文件的目录将会被使用. <BR><BR>name="instanceName" <BR>这个Bean或applet实例的名字，它将会在Jsp其它的地方调用. <BR><BR>archive="URIToArchive, ..." <BR>一些由逗号分开的路径名，这些路径名用于预装一些将要使用的class,这会提高applet的性能. <BR><BR>align="bottom / top / middle / left / right" <BR>图形，对象，Applet的位置,有以下值: <BR><BR>bottom <BR>top <BR>middle <BR>left <BR>right <BR>height="displayPixels" width="displayPixels" <BR>Applet或Bean将要显示的长宽的值，此值为数字，单位为象素. <BR><BR>hspace="leftRightPixels" vspace="topBottomPixels" <BR>Applet或Bean显示时在屏幕左右，上下所需留下的空间，单位为象素. <BR><BR>jreversion="JREVersionNumber / 1.1" <BR>Applet或Bean运行所需的Java Runtime Environment (JRE) 的版本. 缺省值是 1.1. <BR><BR>nspluginurl="URLToPlugin" <BR>Netscape Navigator用户能够使用的JRE的下载地址，此值为一个标准的URL，如http://www.aspcn.com/jsp <BR><BR>iepluginurl="URLToPlugin" <BR>IE用户能够使用的JRE的下载地址，此值为一个标准的URL，如http://www.aspcn.com/jsp <BR><BR>　 <BR><BR>&lt;jsp:params&gt; [ &lt;jsp:param name="parameterName" value="{parameterValue / &lt;%= expression %&gt;}" /&gt; ]+ &lt;/jsp:params&gt; <BR>你需要向applet或Bean传送的参数或参数值。 <BR><BR>&lt;jsp:fallback&gt; text message for user &lt;/jsp:fallback&gt; <BR>一段文字用于Java 插件不能启动时显示给用户的，如果插件能够启动而applet或Bean不能，那么浏览器会有一个出错信息弹出. <BR><BR>========================================================================= <BR>&lt;jsp:setProperty&gt; <BR>设置Bean中的属性值. <BR><BR>JSP语法 <BR>&lt;jsp:setProperty <BR>name="beanInstanceName" <BR>{ <BR>property= "*" / <BR>property="propertyName" [ param="parameterName" ] / <BR>property="propertyName" value="{string / &lt;%= expression %&gt;}" <BR>} <BR>/&gt; <BR>例子 <BR>&lt;jsp:setProperty name="mybean" property="*" /&gt; <BR>&lt;jsp:setProperty name="mybean" property="username" /&gt; <BR>&lt;jsp:setProperty name="mybean" property="username" value="Steve" /&gt; <BR>描述 <BR>&lt;jsp:setProperty&gt;元素使用Bean给定的setter方法，在Bean中设置一个或多个属性值。你在使用这个元素之前必须得使用&lt;jsp:useBean&gt;声明此Bean.因为，&lt;jsp:useBean&gt;和&lt;jsp:setProperty&gt;是联系在一起的，同时这他们使用的Bean实例的名字也应当相匹配（就是说，在&lt;jsp:setProperty&gt;中的name的值应当和&lt;jsp:useBean&gt;中id的值相同) <BR><BR>你能使用多种方法利用&lt;jsp:setProperty&gt;来设定属性值 : <BR><BR>通过用户输入的所有值(被做为参数储存中request对象中)来匹配Bean中的属性 <BR>通过用户输入的指定的值来匹配Bean中指定的属性 <BR>在运行时使用一个表达式来匹配Bean的属性 <BR>每一种设定属性值的方法都有其特定的语法，下面我们会来讲解 <BR><BR>属性及其用法 <BR>name="beanInstanceName" <BR>表示已经在&lt;jsp:useBean&gt;中创建的Bean实例的名字. <BR><BR>property="*" <BR>储存用户在Jsp输入的所有值，用于匹配Bean中的属性。在Bean中的属性的名字必须和request对象中的参数名一致. <BR><BR>从客户传到服器上的参数值一般都是字符类型 ，这些字符串为了能够在Bean中匹配就必须转换成其它的类型，下面的表中列出了Bean属性的类型以及他们的转换方法. <BR><BR>把字符串转化为其它类型的方法. Property 类型 <BR>方法 <BR><BR><BR>boolean or Boolean <BR><BR>java.lang.Boolean.valueOf(String) <BR><BR>byte or Byte <BR><BR>java.lang.Byte.valueOf(String) <BR><BR>char or Character <BR><BR>java.lang.Character.valueOf(String) <BR><BR>double or Double <BR><BR>java.lang.Double.valueOf(String) <BR><BR>integer or Integer <BR><BR>java.lang.Integer.valueOf(String) <BR><BR>float or Float <BR><BR>java.lang.Float.valueOf(String) <BR><BR>long or Long <BR><BR>java.lang.Long.valueOf(String) <BR><BR><BR>如果request对象的参数值中有空值，那么对应的Bean属性将不会设定任何值。同样的，如果Bean中有一个属性没有与之对应的Request参数值，那么这个属性同样也不会设定. <BR><BR>property="propertyName" [ param="parameterName" ] <BR>使用request中的一个参数值来指定Bean中的一个属性值。在这个语法中，property指定Bean的属性名，param指定request中的参数名. <BR><BR>如果bean属性和request参数的名字不同，那么你就必须得指定property和param ，如果他们同名，那么你就只需要指明property就行了. <BR><BR>如查参数值为空（或未初始化),对应的Bean属性不被设定. <BR><BR>property="propertyName" value="{string / &lt;%= expression %&gt;}" <BR>使用指定的值来设定Bean属性。这个值可以是字符串，也可以是表达式。如果这个字符串，那么它就会被转换成Bean属性的类型（查看上面的表).如果它是一个表达式，那么它类型就必须和它将要设定的属性值的类型一致。 <BR><BR>如果参数值为空，那么对应的属性值也不会被设定。另外，你不能在一个&lt;jsp:setProperty&gt;中同时使用param和value <BR><BR>技巧 <BR>如果你使用了property="*",那么Bean的属性没有必要按Html表单中的顺序排序 <BR><BR>======================================================================= <BR>&lt;jsp:useBean&gt; <BR>创建一个Bean实例并指定它的名字和作用范围. <BR><BR>JSP 语法 <BR>&lt;jsp:useBean <BR>id="beanInstanceName" <BR>scope="page / request / session / application" <BR>{ <BR>class="package.class" / <BR>type="package.class" / <BR>class="package.class" type="package.class" / <BR>beanName="{package.class / &lt;%= expression %&gt;}" type="package.class" <BR>} <BR>{ <BR>/&gt; / <BR>&gt; other elements &lt;/jsp:useBean&gt; <BR>} <BR>例子 <BR>&lt;jsp:useBean id="cart" scope="session" class="session.Carts" /&gt; <BR>&lt;jsp:setProperty name="cart" property="*" /&gt; <BR>&lt;jsp:useBean id="checking" scope="session" class="bank.Checking" &gt; <BR>&lt;jsp:setProperty name="checking" property="balance" value="0.0" /&gt; <BR>&lt;/jsp:useBean&gt; <BR><BR>描述 <BR>&lt;jsp:useBean&gt;用于定位或示例一个JavaBeans组件。&lt;jsp:useBean&gt;首先会试图定位一个Bean实例，如果这个Bean不存在，那么&lt;jsp:useBean&gt;就会从一个class或模版中进行示例。 <BR><BR>为了定位或示例一个Bean，&lt;jsp:useBean&gt;会进行以下步聚，顺序如下: <BR><BR>通过给定名字和范围试图定位一个Bean. <BR>对这个Bean对象引用变量以你指定的名字命名. <BR>如果发现了这个Bean,将会在这个变量中储存这个引用。如果你也指定了类型，那么这个Bean也设置为相应的类型. <BR>如果没有发现这个Bean,将会从你指定的class中示例，并将此引用储存到一个新的变量中去。如果这个class的名字代表的是一个模版，那么这个Bean被java.beans.Beans.instantiate示例. <BR>如果&lt;jsp:useBean&gt;已经示例（不是定位）了Bean,同时&lt;jsp:useBean&gt;和&lt;/jsp:useBean&gt;中有元素，那么将会执行其中的代码. <BR>&lt;jsp:useBean&gt;元素的主体通常包含有&lt;jsp:setProperty&gt;元素，用于设置Bean的属性值。正如上面第五步所说的，&lt;jsp:useBean&gt;的主体仅仅只有在&lt;jsp:useBean&gt;示例Bean时才会被执行，如果这个Bean已经存在，&lt;jsp:useBean&gt;能够定位它，那么主体中的内容将不会起作用 <BR><BR>属性以及用法 <BR>id="beanInstanceName" <BR>在你所定义的范围中确认Bean的变量，你能在后面的程序中使用此变量名来分辨不同的Bean <BR><BR>这个变量名对大小写敏感，必须符合你所使用的脚本语言的规定，在Java Programming Language中，这个规定在Java Language 规范已经写明。如果这个Bean已经在别的&lt;jsp:useBean&gt;中创建，那么这个id的值必须与原来的那个id值一致. <BR><BR>scope="page / request / session / application" <BR>Bean存在的范围以及id变量名的有效范围。缺省值是page,以下是详细说明： <BR><BR>　 <BR><BR>page - 你能在包含&lt;jsp:useBean&gt;元素的JSP文件以及此文件中的所有静态包含文件中使用Bean,直到页面执行完毕向客户端发回响应或转到另一个文件为止。 <BR>　 <BR><BR>request - 你在任何执行相同请求的Jsp文件中使用Bean,直到页面执行完毕向客户端发回响应或转到另一个文件为止。你能够使用Request对象访问Bean,比如request.getAttribute(beanInstanceName) <BR>　 <BR><BR>session - 从创建Bean开始，你就能在任何使用相同session的Jsp文件中使用Bean.这个Bean存在于整个Session生存周期内，任何在分享此Session的Jsp文件都能使用同一Bean.注意在你创建Bean的Jsp文件中&lt;% @ page %&gt;指令中必须指定session=true <BR>　 <BR><BR>application - 从创建Bean开始，你就能在任何使用相同application的Jsp文件中使用Bean.这个Bean存在于整个application生存周期内，任何在分享此application的Jsp文件都能使用同一Bean. <BR>class="package.class" <BR>使用new关键字以及class构造器从一个class中示例一个bean.这个class不能是抽象的，必须有一个公用的，没有参数的构造器.这个package的名字区别大小写。 <BR><BR>type="package.class" <BR>如果这个Bean已经在指定的范围中存在，那么写这个Bean一个新的数据库类型 。如果你没有使用class或beanName指定type，Bean将不会被示例.package和class的名字，区分大小写. <BR><BR>beanName="{package.class / &lt;%= expression %&gt;}" type="package.class" <BR>使用java.beans.Beans.instantiate方法来从一个class或连续模版中示例一个Bean,同时指定Bean的类型。 <BR><BR>beanName可以是package和class也可以是表达式,它的值会传给Beans.instantiate.tupe的值可以和Bean相同。 <BR><BR>package 和 class 名字区分大小写.</div>
</body>
</html>
